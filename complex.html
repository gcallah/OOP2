<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
        code/misc/complex.cpp
        </title>
    </head>
    <body>
        <div style="text-align:center">
            <p>
				<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/140px-ISO_C%2B%2B_Logo.svg.png" width="8%">
            </p>
        </div>

<p class="menu">
	<a href="index.html">Home</a>
	&nbsp;|&nbsp;
	<a href="code.html">Code</a>
	&nbsp;|&nbsp;
	<a href="resources.html">Resources</a>
	&nbsp;|&nbsp;
	<a href="about.html">About</a>
</p>
        <h1>
        code/misc/complex.cpp
        </h1>

                <p>
  FILE: complex.cpp
  THEME: operator over-loading.
  CLASSES: Complex

                </p>

                <pre>
                <code>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
using namespace std;

const bool DEBUG = true;
class Complex {

</code>
                </pre>
                <p>
      A partial implementation of a complex number class,
      designed to illustrate operator over-loading.

                </p>

                <pre>
                <code>
    friend ostream& operator&lt;&lt; (ostream& os, const Complex& c);
    friend istream& operator&gt;&gt; (istream& is, Complex& c);


</code>
                </pre>
                <p>
      The equality operator is a friend since it is binary
      and symmetrical.

                </p>

                <pre>
                <code>
    friend bool operator== (const Complex& c1, const Complex& c2) {
        return ((c1.real == c2.real) && (c1.imag == c2.imag));
    }
    public:
    

</code>
                </pre>
                <p>
      Our sole constructor takes defaults of 0 for both `real` and 
      `imag`, so can be called with no arguments.

                </p>

                <pre>
                <code>
        Complex(double real=0.0, double imag=0.0)
            : real{real}, imag{imag} {}

</code>
                </pre>
                <p>
          The `bool` operator tests to see if either
          data member is non-zero, and returns `true`
          if so.

                </p>

                <pre>
                <code>
        explicit operator bool() const {
            return ((real != 0) || (imag != 0));
        }


</code>
                </pre>
                <p>
          This overload is pre-increment: pretty straightforward:
          bump up the `real` member, and return myself.
          Of course, it's not obvious that this is what incrementing
          a complex number should do: but we are teaching here,
          not writing a production Complex class.

                </p>

                <pre>
                <code>
        Complex& operator++() {
            ++real;
            return (*this);
        }

</code>
                </pre>
                <p>
          Post-increment is more complicated than pre: first
          of all, it takes a dummy int parameter (unused)
          just so the compiler can tell which inc operator is which.
          Secondly, since it returns the value from before
          the increment, we must store that in a temp var.

                </p>

                <pre>
                <code>
        Complex operator++(int dummy) {
            Complex temp(*this);
            real++;
            return temp;
        }


</code>
                </pre>
                <p>
          `+` is very straightforward, and should be the first operator
          taught.

                </p>

                <pre>
                <code>
        Complex operator+(const Complex& c) {
            Complex sum{real + c.real, imag + c.imag};
            return sum;
        }
    private:
        double real;
        double imag;
};

ostream& operator&lt;&lt; (ostream& os, const Complex& c) {

</code>
                </pre>
                <p>
      Outputting a `Complex` instance, while illustrating some of the
      capabilities of I/O streams: `setprecision` gives us a fixed
      number of decimal places, while `showpos` turns on the plus
      sign for positive numbers.

                </p>

                <pre>
                <code>
    os &lt;&lt; setprecision(10) &lt;&lt; c.real &lt;&lt; showpos 
         &lt;&lt; c.imag &lt;&lt; "i" &lt;&lt; noshowpos &lt;&lt; endl;
    return os;
}


</code>
                </pre>
                <p>
  Read a `Complex` number from an input stream.

                </p>

                <pre>
                <code>
istream& operator&gt;&gt; (istream& is, Complex& c) {
    is &gt;&gt; c.real &gt;&gt; c.imag;
    return is;
}

void printVector(const vector&lt;Complex&gt;& v);


</code>
                </pre>
                <p>
  The code in main just exercizes the `Complex` class.

                </p>

                <pre>
                <code>
int main() {
    cout &lt;&lt; "Input a complex number:\n";
    Complex c1;
    // get a complex from stdin:
    cin &gt;&gt; c1;
    if(!cin)
    {
        cerr &lt;&lt; "Bad input format\n";
        exit(1);
    }
    if(DEBUG)
    {
        cout &lt;&lt; "c1 = " &lt;&lt; c1 &lt;&lt; endl;
    }

    Complex c2{43.2, 58.9};
    if(DEBUG) 
    {
        cout &lt;&lt; "c2 = " &lt;&lt; c2 &lt;&lt; endl;
    }
    // see if `Complex` addition works:
    Complex c3 = c1 + c2;

    Complex c4 = Complex();
    // test post-increment:
    c4++;
    // test equality operator:
    (1 == c4) ? cout &lt;&lt; "c4 == 1 is true\n" 
        : cout &lt;&lt; "c4 == 1 is false\n";
    // test bool() operator:
    (c4) ? cout &lt;&lt; "c4 is true\n" : cout &lt;&lt; "c4 is false\n";

</code>
                </pre>
                <p>
      The next line of code will implicitly
      construct a Complex out of 14.2 using the default
      imaginary component of 0.0.

                </p>

                <pre>
                <code>
    Complex c5 = 14.2;

    vector&lt;Complex&gt; v{c1, c2, c3, c4, c5};
    cout &lt;&lt; "Printing vector\n";
    printVector(v);
}


</code>
                </pre>
                <p>
  Print a vector of type Complex: templates haven't been taught yet!

                </p>

                <pre>
                <code>
void printVector(const vector&lt;Complex&gt;& v)
{
    // auto detects the type coming from the vector automatically:
    for(auto c : v) {
        cout &lt;&lt; c;
    }
}


</code>
                </pre>

    </body>
</html>

