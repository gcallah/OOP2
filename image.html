<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
        code/weather/image.cpp
        </title>
    </head>
    <body>
        <div style="text-align:center">
            <p>
				<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/140px-ISO_C%2B%2B_Logo.svg.png" width="8%">
            </p>
        </div>

<p class="menu">
	<a href="index.html">Home</a>
	&nbsp;|&nbsp;
	<a href="code.html">Code</a>
	&nbsp;|&nbsp;
	<a href="resources.html">Resources</a>
	&nbsp;|&nbsp;
	<a href="about.html">About</a>
</p>
        <h1>
        code/weather/image.cpp
        </h1>

                <pre>
                <code>
// Copyright 2019 Gene Callahan


</code>
                </pre>
                <p>
  This is the implementation of our image class.
  It is designed to teach class hierarchy.

                </p>

                <pre>
                <code>
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
#include "./image.h"


</code>
                </pre>
                <p>
  "Ordinary" constructor initializing each field:

                </p>

                <pre>
                <code>
Image::Image(int width, int height, string flnm)
    : width(width), height(height) {
    image_buf = new unsigned char[image_sz()];
}


</code>
                </pre>
                <p>
  This is the `Image` copy constructor. We have to handle 
  properly copying the `image_buf` to the target object.

                </p>

                <pre>
                <code>
Image::Image(const Image& img2) {
    copy_fields(img2);
}


</code>
                </pre>
                <p>
  `Image` destructor must free the image buf.

                </p>

                <pre>
                <code>
Image::~Image() {
    if (image_buf != nullptr) delete image_buf;
}


</code>
                </pre>
                <p>
  The `Image` assignment operator has to delete the image buf is
  not null, then do the copy like the copy constructor.

                </p>

                <pre>
                <code>
Image& Image::operator=(const Image& img2) {
    if (image_buf != nullptr) delete image_buf;
    copy_fields(img2);
    return *this;
}

string Image::display(string s="Base") {
    cout &lt;&lt; s &lt;&lt; endl;
    return s;
}

int Image::image_sz() { return width * height; }


</code>
                </pre>
                <p>
  We extract the copy into its own method so that it can be shared
  by the copy constructor and assignment.

                </p>

                <pre>
                <code>
void Image::copy_fields(const Image& img2) {
    width = img2.width;
    height = img2.height;
    image_buf = new unsigned char[image_sz()];
    for (int i = 0; i &lt; image_sz(); i++)
        image_buf[i] = img2.image_buf[i];
}


</code>
                </pre>
                <p>
  Correct way to call base class copy constructor:

                </p>

                <pre>
                <code>
Gif::Gif(const Gif& img2) : Image(img2) {
}


</code>
                </pre>
                <p>
  Incorrect wat to call it:
Gif::Gif(const Gif& img2) {
    Image(img2);
}

                </p>

                <pre>
                <code>


</code>
                </pre>
                <p>
  Specialized over-ridden display method for Gif.
  In it we call the parent display method with
  `Image::display()`.

                </p>

                <pre>
                <code>
string Gif::display(string s) { 
    return Image::display("Gif");
}


</code>
                </pre>
                <p>
  Gif has its own `compress()` with an int parameter.
  It will hide the base class `compress()` unless we
  explicitly prevent it from doing so.

                </p>

                <pre>
                <code>
void Gif::compress(int i) {
    cout &lt;&lt; "compressing at level: " &lt;&lt; i &lt;&lt; endl;
}


</code>
                </pre>
                <p>
  Specialized over-ridden display method for AnimGif.
  In it we call the parent display method with
  `Image::display()`.

                </p>

                <pre>
                <code>
string AnimGif::display(string s) { 
    return Image::display("AnimGif");
}


</code>
                </pre>
                <p>
  Specialized over-ridden display method for Jpeg.
  In it we call the parent display method with
  `Image::display()`.

                </p>

                <pre>
                <code>
string Jpeg::display(string s) { 
    return Image::display("Jpeg");
}


</code>
                </pre>
                <p>
  Specialized over-ridden display method for Png.
  In it we call the parent display method with
  `Image::display()`.

                </p>

                <pre>
                <code>
string Png::display(string s) { 
    return Image::display("Png");
}

</code>
                </pre>

    </body>
</html>

