<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
        code/misc/stl.cpp
        </title>
    </head>
    <body>
        <div style="text-align:center">
            <p>
				<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/140px-ISO_C%2B%2B_Logo.svg.png" width="8%">
            </p>
        </div>

<p class="menu">
	<a href="index.html">Home</a>
	&nbsp;|&nbsp;
	<a href="code.html">Code</a>
	&nbsp;|&nbsp;
	<a href="resources.html">Resources</a>
	&nbsp;|&nbsp;
	<a href="about.html">About</a>
</p>
        <h1>
        code/misc/stl.cpp
        </h1>

                <p>
  Let's use the Standard Template Library!
  First, we will include the headers we need:

                </p>

                <pre>
                <code>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

</code>
                </pre>
                <p>
  Let's make a template for a print_list that can handle
  lists of any type:

                </p>

                <pre>
                <code>
template &lt;typename T&gt;
void print_list(const string name, const list&lt;T&gt;& l) {
    cout &lt;&lt; "\n_______" &lt;&lt; endl;

    cout &lt;&lt; name &lt;&lt; ":\n";
    for (T item : l) cout &lt;&lt; item &lt;&lt; " ";
    cout &lt;&lt; "\n_______" &lt;&lt; endl;
}


</code>
                </pre>
                <p>
  But, we can go even more generic, and make a print that can print
  containers of any sequential type:

                </p>

                <pre>
                <code>
template &lt;typename SequenceContainer&gt;
void print(const string name, const SequenceContainer& seq) {
    cout &lt;&lt; "\n_______" &lt;&lt; endl;
    cout &lt;&lt; name &lt;&lt; ":\n";
    for(auto& item : seq) cout &lt;&lt; item &lt;&lt; " ";
    cout &lt;&lt; "\n_______" &lt;&lt; endl;
}
class Cat {
    friend ostream& operator&lt;&lt;(ostream& os, const Cat& cat) {
        os &lt;&lt; "meow ";
        return os;
    }
};


</code>
                </pre>
                <p>
  We could pass this `is_odd()` function in to a `find_if()`,
  or pass a lambda instead.

                </p>

                <pre>
                <code>
bool is_odd(int n) { return (n % 2) != 0; }

</code>
                </pre>
                <p>
  Or, we could have a functor!

                </p>

                <pre>
                <code>
class IsOdd {
    public:
        bool operator()(int n) { return (n % 2) != 0; }
};


</code>
                </pre>
                <p>
  Our main will exercise some STL capabilities.

                </p>

                <pre>
                <code>
int main() {
    int bjarnelen = 17;
    int dennislen = 14;
    char s[]  = "Bjarne Stroustrup";
    char s2[] = "Dennis Ritchie";

    cout &lt;&lt; "C++ creator: " &lt;&lt; s &lt;&lt; "\n";
    cout &lt;&lt; "C creator, 4th letter: " &lt;&lt; s2[3] &lt;&lt; "\n";

</code>
                </pre>
                <p>
      Let's do some things with a vector.
      We will create it with a half-open range, and then sort it.

                </p>

                <pre>
                <code>
    vector&lt;char&gt; cvec(s2, s2 + dennislen);
    print("cvec", cvec);
    sort(cvec.begin(), cvec.end());
    print("sorted cvec", cvec);


</code>
                </pre>
                <p>
      Create a char list:

                </p>

                <pre>
                <code>
    list&lt;char&gt; clist(s, s + bjarnelen);
    list&lt;char&gt; clist2 = clist;

</code>
                </pre>
                <p>
      The STL provides us with a `reverse()` functions that
      reverses an iterable structure:

                </p>

                <pre>
                <code>
    reverse(clist.begin(), clist.end());

</code>
                </pre>
                <p>
      We use print_list here just to make sure it works, but print()
      is preferred!

                </p>

                <pre>
                <code>
    print_list("clist reversed", clist);

</code>
                </pre>
                <p>
      But even after `clist` is reversed, `clist` and
      `clist2` are still permutations of each other:

                </p>

                <pre>
                <code>
    cout &lt;&lt; "Is clist a permutation of clist2? "
        &lt;&lt; is_permutation(clist.begin(), clist.end(), clist2.begin())
        &lt;&lt; endl; ;

</code>
                </pre>
                <p>
      Cat list

                </p>

                <pre>
                <code>
    Cat catptr[] = { Cat(), Cat(), Cat() };
    list&lt;Cat&gt; catlist(catptr, catptr + 3);
    print_list("Cat list", catlist);


</code>
                </pre>
                <p>
      int list:

                </p>

                <pre>
                <code>
    int ilen = 8;
    int iptr[] = { 16, 32, 64, 128, 2, 4, 8, 17 };
    list&lt;int&gt; ilist(iptr, iptr + ilen);

</code>
                </pre>
                <p>
      Our print can work for lists as well as vectors:

                </p>

                <pre>
                <code>
    print("ilist", ilist);

</code>
                </pre>
                <p>
      `sort()` does not work for lists, since they aren't random access.
      Thus lists have their own `sort()` method, called below:
      This won't work: sort(ilist.begin(), ilist.end());

                </p>

                <pre>
                <code>
    ilist.sort();
    print("ilist sorted", ilist);

</code>
                </pre>
                <p>
      Let's experiment with iterators a bit!

                </p>

                <pre>
                <code>
    list&lt;int&gt;::iterator iiter = find(ilist.begin(), ilist.end(), 8);
    cout &lt;&lt; "After find(), iter is at: " &lt;&lt; *iiter &lt;&lt; endl;
    ++iiter;
    if (iiter != ilist.end()) {
        cout &lt;&lt; "After increment, iter is at: " &lt;&lt; *(iiter) &lt;&lt; endl;
    }


</code>
                </pre>
                <p>
      Here we are going to pass `is_odd() to `find_if()`.

                </p>

                <pre>
                <code>
    list&lt;int&gt;::iterator if_iter1 = find_if(ilist.begin(), ilist.end(),
            is_odd);
    cout &lt;&lt; "First is_odd() number in list is: " &lt;&lt; *if_iter1 &lt;&lt; endl;

</code>
                </pre>
                <p>
      Here we are going to pass functor IsOdd to `find_if()`.

                </p>

                <pre>
                <code>
    list&lt;int&gt;::iterator if_iter2 = find_if(ilist.begin(), ilist.end(),
            IsOdd());
    cout &lt;&lt; "First IsOdd number in list is: " &lt;&lt; *if_iter2 &lt;&lt; endl;


</code>
                </pre>
                <p>
      Here we are going to pass a lambda to `find_if()`.
      The lambda starts with []. The point here is to show
      that this form and the one above are identical in effect.

                </p>

                <pre>
                <code>
    list&lt;int&gt;::iterator if_iter3 = find_if(ilist.begin(),
            ilist.end(), [] (int n) { return (n % 2) != 0; });
    cout &lt;&lt; "First lambda odd number in list is: " &lt;&lt; *if_iter3 &lt;&lt; endl;
}

</code>
                </pre>

    </body>
</html>

